
This week, I took a look at the current code base, both OSS pogo and YPogo, and
thought about how we can better structure OSS Pogo to arrive at a more robust
code base than what we have now.

I think the high-level architecture as a whole (dispatcher/zookeeper/workers)
is solid, but what we need to easier understand/debug the internal workings of
OSS Pogo is to break up the unstructured code into reusable components that are
unit-testable. We also need a better feedback mechanism between the worker
and the dispatcher, be able to kill dangling worker tasks and resilience
against dispatcher restarts.

Also, we need to stick to a programming paradign. The AnyEvent framework
Pogo uses has a good reputation with some leading Perl folks, it's just
that Pogo isn't using it in a easily readable manner.

So, my goal is to split up Pogo functionality into easily testable 
AnyEvent components. Components are classes and are all defined and
used in the same way. Take the class for the new worker's task executor,
for example:

    package use Pogo::Worker::Task::Command;
    use AnyEvent;
    use base qw(Object::Event);

    my $cmd = Pogo::Worker::Task::Command->new(
      cmd  => [ 'ls', '-l' ],
    };

    $cmd->reg_cb(
      on_stdout => sub {
        my($c, $stdout) = @_;
      },
      on_stderr => sub {
        my($c, $stderr) = @_;
      }
      on_eof => sub {
        my($c) = @_;
      }
    );
          
    $cmd->run();

After constructing the object with parameters, the reg_cb() method
(coming via Object::Event) is used to register callback on significant
events. The component has a run() method which starts it.

In the case of the worker task executor, the callbacks are for the events
on_stdout (process writes to stdout), on_stdout (process writes to stderr),
and on_eof (process ended). Every callback gets as its first argument
a reference to the object itself and optional parameters, for example
the stdout string in case of the on_stdout event.

Internally, if the component wants to trigger an event, it uses

    $self->event (on_stdout => $string);

which jumps to the on_stdout callback registered before.

Events differ from component class to 
component class, but it's important to stick to a general format to 
make it easy for new people to come on board and start coding.

If you want to unit-test the component, you just wrap

    my $cv = AnyEvent->condvar;

    ...

    $cv->recv;

around the code and use $cv->send from somewhere within a callback
(e.g. "eof") to terminate the implicitly started event loop. Check
the AnyEvent::Intro page for details.

It takes some time to get the hang of it, but it's a good framework, 
I think.

=======
CLASSES
=======

Here's the components I've mapped out so far, some already 
checked into github (but I've hardly written any code yet):

Pogo::Worker - Main worker daemon

Pogo::Worker::Connection - Connection/Reconnection Logic with Dispatcher,
supports both regular sockets (testing) and SSL sockets (production).
Maintains a message send queue to the dispatcher. The dispatcher needs
to ACK every message, if it doesn't, the worker will keep it in its
message queue.

Pogo::Worker::Task - Gets events for and executes worker tasks like: 
running commands, querying status, killing job tasks currently 
running/hanging on the worker.

Pogo::Worker::Task::Command - Run local command (not used, just a base class)

Pogo::Worker::Task::Command::Remote - Run command on target host

=======
TOOLS
=======

To make it easier to create new modules (or scripts), I've checked in
adm/pogo-tmpl which you can use like

    ..../adm/pogo-tmpl Frobnicator.pm

or 

   ..../adm/pogo-tmpl pogo-frobnicate

and which will create the newly requested files from pogo-compliant 
templates.

